Program 1:
Using methods charAt() & length() of String class, write a program to print the frequency of each character in a string. “Hello friend”

import java.util.Scanner;
public class Main
{
public static void main(String[] args) {
int i;
        String str;
     
        int count[] = new int[256];
        Scanner s = new Scanner(System.in);
       
        System.out.print("Enter a String : ");
        str=s.nextLine();
       
         for (i = 0; i < str.length(); i++) {
            count[(int) str.charAt(i)]++;
        }
        for (i = 0; i < 256; i++) {
            if (count[i] != 0) {
                  System.out.println( (char) i  + " : " + count[i]);
            }
        }
}
}

Program 2:
Write down a java program to print even and odd numbers series respectively from two threads: t1 and t2 synchronizing on a shared object Let t1 print message “ping — >” and t2 print message “,—-pong”.

public class PingPong extends Thread {
static StringBuilder object = new StringBuilder("");

public static void main(String[] args) throws InterruptedException {

Thread t1 = new PingPong();
Thread t2 = new PingPong();

t1.setName("\nping");
t2.setName(" pong");

t1.start();
t2.start();
}

@override
public void run() {
working();
}

void working() {
while (true) {
synchronized (object) {
try {
System.out.print(Thread.currentThread().getName());
object.notify();
object.wait();
} catch (InterruptedException e) {
e.printStackTrace();
}
}
}
}
}

Program 3:
We have a Letter or a word then we need add some letters to it and need to find out shortest palindrome
For example we take "S": S will be the shortest palindrome string.
If we take "xyz": zyxyz will be the shortest palindrome string
So we need to add some characters to the given string or character and find out what will be the shortest palindrome string by using simple java program.

package shortestpalindromeexample.java;
import java.util.Scanner;
public class ShortestPalindromeDemo {
public static String shortestPalindrome(String str) {
int x=0;
int y=str.length()-1;
while(y>=0){
if(str.charAt(x)==str.charAt(y)){
x++;
}
y--;
}
if(x==str.length())
return str;
String suffix = str.substring(x);
String prefix = new StringBuilder(suffix).reverse().toString();
String mid = shortestPalindrome(str.substring(0, x));
return prefix+mid+suffix;
}
public static void main(String[] args) {
Scanner in = new Scanner(System.in);
System.out.println("Enter a String to find out shortest palindrome");
String str=in.nextLine();
System.out.println("Shortest palindrome of "+str+" is "+shortestPalindrome(str));
}

Program 4:

Write a simple code to identify given linked list is palindrome or not by using stack.
First take a Stack. Traverse through each node of the linked list and push each node value to Stack.
Once the traversal & copying is done, iterate through linked list from head node again.
In each iteration, pop one stack element and compare with node value in respective iteration. It is expected to match stack popped value with node value.
In case of all matches, its a palindrome. Any one element mismatch makes it not a palindrome.


import java.util.Stack;
class Node {
int data;
Node next;
Node(int i)
{
this.data = i;
this.next = null;
}
};
class Main
{
public static boolean isPalindrome(Node head)
{
Stack s = new Stack<>();
Node node = head;
while (node != null) {
	s.push(node.data);
	node = node.next;
}
node = head;
while (node != null)
{
	int top = s.pop();
	if (top != node.data) {
		return false;
	}
	node = node.next;
}

return true;
}
public static void main(String[] args)
{
Node head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(2);
head.next.next.next.next = new Node(1);
if (isPalindrome(head)) {
	System.out.print("Linked List is a palindrome.");
} else {
	System.out.print("Linked List is not a palindrome.");
}
}

Program 5:
Write a C Program to Reverse a Linked List in groups of given size.

struct Node
{
int data;
struct Node* next;
};

pointer to the new head node. /
struct Node reverse (struct Node head, int k)
{
struct Node current = head;
struct Node next = NULL;
struct Node prev = NULL;
int count = 0;

while (current != NULL && count < k) 
{ 
    next  = current->next; 
    current->next = prev; 
    prev = current; 
    current = next; 
    count++; 
} 
  
if (next !=  NULL) 
   head->next = reverse(next, k);  

return prev; 
}

void push(struct Node** head_ref, int new_data)
{
struct Node* new_node =
(struct Node*) malloc(sizeof(struct Node));

new_node->data  = new_data; 

new_node->next = (*head_ref);     

(*head_ref)    = new_node; 
}

void printList(struct Node *node)
{
while (node != NULL)
{
printf("%d ", node->data);
node = node->next;
}
}

int main(void)
{
struct Node* head = NULL;
push(&head, 8);
push(&head, 7);
push(&head, 6);
push(&head, 5);
push(&head, 4);
push(&head, 3);
push(&head, 2);
push(&head, 1);

 printf("\nGiven linked list \n"); 
 printList(head); 
 head = reverse(head, 2); 

 printf("\nReversed Linked list \n"); 
 printList(head); 

 return(0);

Program 6:
def find_longest_word(words_list):
    word_len = []
    for n in words_list:
        word_len.append((len(n), n))
    word_len.sort()
    return word_len[-1][1]

print(find_longest_word(["PHP", "Exercises", "Backend"]))